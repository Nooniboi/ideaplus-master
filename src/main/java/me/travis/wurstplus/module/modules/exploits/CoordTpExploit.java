package me.travis.wurstplus.module.modules.exploits;

import me.travis.wurstplus.module.Module;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.math.Vec3d;
import net.minecraft.entity.Entity;
import java.util.HashMap;
import me.travis.wurstplus.util.WorldUtils;
import me.travis.wurstplus.command.Command;
import java.io.PrintWriter;
import java.io.File;
import java.io.FileWriter;

@Module.Info(name = "CoordTpExploit", category = Module.Category.EXPLOITS)
public class CoordTpExploit extends Module {
    private HashMap<Entity, Vec3d> knownPlayers;
    private HashMap<String, Vec3d> tpdPlayers;
    private int numTicks;
    private int numForgetTicks;

    public CoordTpExploit() {
        this.knownPlayers = new HashMap<Entity, Vec3d>();
        this.tpdPlayers = new HashMap<String, Vec3d>();
        this.numTicks = 0;
        this.numForgetTicks = 0;
    }

    public void dump() {
        for (final Entity entity : CoordTpExploit.mc.world.loadedEntityList) {
            if (entity instanceof EntityPlayer) {
                System.out.println(entity.getName() + ": "
                        + WorldUtils.vectorToString(entity.getPositionVector(), new boolean[0]));
                Command.sendChatMessage(entity.getName() + ": "
                        + WorldUtils.vectorToString(entity.getPositionVector(), new boolean[0]));
            }
        }
    }

    public void clear() {
        this.knownPlayers.clear();
    }

    public void saveFile(String pos, String name) {
        try {
            File file = new File("./wurst+_coords.txt");
            file.getParentFile().mkdirs();
            PrintWriter writer = new PrintWriter(new FileWriter(file, true));
            writer.println("name: "+name+" coords: "+pos);
            writer.close();
        } catch (Exception e) {
            Command.sendChatMessage("Error saving file: "+e);
        }
        
    }

    public void onUpdate() {
        if (!this.isEnabled()) {
            return;
        }
        if (this.numTicks >= 50) {
            this.numTicks = 0;
            for (final Entity entity : CoordTpExploit.mc.world.loadedEntityList) { // for each nearby entity
                if (entity instanceof EntityPlayer && !entity.getName().equals(CoordTpExploit.mc.player.getName())) { // if the entity is a player and is not you
                    final Vec3d playerPos = new Vec3d((double) (int) entity.posX, (double) (int) entity.posY, 
                            (double) (int) entity.posZ);
                    if (this.knownPlayers.containsKey(entity)) {
                        if (Math.abs(this.knownPlayers.get(entity).distanceTo(playerPos)) > 50.0
                                && Math.abs(CoordTpExploit.mc.player.getPositionVector().distanceTo(playerPos)) > 100.0
                                && (!this.tpdPlayers.containsKey(entity.getName())
                                        || this.tpdPlayers.get(entity.getName()) != playerPos)) {

                            Command.sendChatMessage("Player " + entity.getName() + " teleported to "
                                    + WorldUtils.vectorToString(playerPos, new boolean[0]));
                            saveFile(WorldUtils.vectorToString(playerPos, new boolean[0]), entity.getName());
                            this.knownPlayers.remove(entity);
                            this.tpdPlayers.put(entity.getName(), playerPos);
                        }
                        this.knownPlayers.put(entity, playerPos);
                    } else {
                        this.knownPlayers.put(entity, playerPos);
                    }
                }
            }
        }
        if (this.numForgetTicks >= 9000000) {
            this.tpdPlayers.clear();
        }
        ++this.numTicks;
        ++this.numForgetTicks;
    }
}
